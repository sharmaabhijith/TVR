# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FZ_0iWQc5Bsg5xfVWCbFepLIB9bSJ6y6

# **Imagenet-Patch Hands-On**

In this tutorial we aim to show how to use the optimized patch and test the robustness of a PyTorch model.
"""
from __future__ import print_function, division

import os
import sys
import copy
import math
import time
import cv2
import shutil
import sys
from tqdm import tqdm
from glob import glob
from pathlib import Path
from collections import defaultdict

import numpy as np
import pandas as pd
import seaborn as sns
from PIL import Image
from matplotlib import rc
from pylab import rcParams
import matplotlib.pyplot as plt
plt.ion()   # interactive mode
from statistics import mode

import torch
import torch.nn as nn
import torch.optim as optim
from torch.optim import lr_scheduler
from torch.autograd import Variable
import torch.nn.functional as F
from torch.utils.data import random_split
from torch.utils.data.sampler import SubsetRandomSampler

import torchvision
import torchvision.utils as vutils
import torch.nn.functional as F
import torchvision.transforms as T
from torch.utils.data import DataLoader
from torchvision.datasets import CIFAR10
from torchvision.datasets import ImageFolder
from torchvision import datasets, models, transforms
from torchmetrics import TotalVariation

device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

from torchvision.transforms import Compose, Resize, CenterCrop, ToTensor, Normalize
import torchvision.models as models

from utils.utils import set_all_seed
from utils.utils import target_transforms
from transforms.apply_patch import ApplyPatch

import utils_def
from utils_def import total_Variation_Defense, test_Accuracy, select_Model, result_Log, generator, discriminator

import gzip
import pickle

import os

set_all_seed(42)

# dictionary with the ImageNet label names
with open(os.path.join(os.getcwd(), "./assets/imagenet1000_clsidx_to_labels.txt")) as f:
    target_to_classname = eval(f.read())

# Load the patches
with gzip.open(os.path.join(os.getcwd(), "./assets/imagenet_patch.gz"), 'rb') as f:
    imagenet_patch = pickle.load(f)
patches, targets, info = imagenet_patch

# Mean and standard deviation
MEAN = [0.485, 0.456, 0.406]
STD = [0.229, 0.224, 0.225]

# For convenience the preprocessing steps are splitted to compute also the clean predictions
normalizer = Normalize(mean=[0.485, 0.456, 0.406],
                       std=[0.229, 0.224, 0.225])
inv_normalizer = transforms.Normalize(mean=[-0.485/0.229, -0.456/0.224, -0.406/0.255],
                        std=[1/0.229, 1/0.224, 1/0.255])

# Load the data
preprocess = Compose([Resize(256), CenterCrop(224), ToTensor()])    # ensure images are 224x224

_imagenette_classes = [0, 217, 482, 491, 497, 566, 569, 571, 574, 701]
target_transforms = lambda y: _imagenette_classes[y]

set_all_seed(42)
# Test
test_dataset = ImageFolder('./assets/data/', transform = preprocess, target_transform = target_transforms)
test_idx = np.arange(len(test_dataset))
np.random.shuffle(test_idx)
testing_idx = test_idx[:50]
test_loader = DataLoader(test_dataset, batch_size=1, sampler=SubsetRandomSampler(testing_idx), num_workers=2)

COLS = ['NAT_ACC_NAIVE', 'ADVER_ACC_NAIVE', 'SUCCESS_NAIVE', 'NAT_ACC_DEF',  'ADVER_ACC_DEF', 'SUCCESS_DEF']
ROWS = ['alexnet', 'resnet18', 'squeezenet', 'vgg16', 'googlenet', 'inception_v3']
patch_class = ['soap_dispenser', 'cornet', 'plate', 'banana', 'cup', 'typewriter', 'electric_guitar', 'hair_spray', 'sock', 'cellular_telephone']
model_names = ROWS
k=1
blk_list = [7, 14, 28, 56, 112]
cls = 1
PATH = './Model/netG.pt'
netG = generator()
netG.load_state_dict(torch.load(PATH))
netG.eval()

for block_size in blk_list:

  patch = patches[cls]
  target = targets[cls]
  print(patch_class[cls], target)

  NAT_ACC_NAIVE, ADVER_ACC_NAIVE, SUCCESS_NAIVE = test_Accuracy(test_loader, patch, info, target, model_names, k, block_size, netG, defense=False)
  NAT_ACC_DEF, ADVER_ACC_DEF, SUCCESS_DEF = test_Accuracy(test_loader, patch, info, target, model_names, k, block_size, netG, defense=True)

  RES_SAVE_PATH = './results/' + patch_class[cls] + '_' + str(k) + '_blk_' + str(block_size) + '.csv'

  result_Log(RES_SAVE_PATH, ROWS, COLS, NAT_ACC_NAIVE, ADVER_ACC_NAIVE, SUCCESS_NAIVE, NAT_ACC_DEF, ADVER_ACC_DEF, SUCCESS_DEF)

